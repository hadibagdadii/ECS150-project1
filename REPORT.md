Phase 0: In this phase we first started by opening the skeleton code and understanding the workings of a shell and how to properly format and code our own shell. We took time to understand the code and what each line did, and why each line was important. We also developed a makefile, one that creates an executable called shell with the proper error flags. 
Phase 1: In this phase we replaced the system() function with the fork+exec+wait method, we used the lecture slides as a reference point for using this method. Our first priority was to test terminal commands that took no arguments in order to verify the correctness of our preliminary shell. 
Phase 2: In this phase we focused on implementing functionality for multiple arguments and flags, our priority was to make it, so our shell was able to read the whole command line and differentiate from flags, arguments, or just plain text. We first approached this by creating several linked lists, each containing the different variety of input that were possible, and from there, iterating through that list and executing the commands and flags. However, after further reflection this method was sub-par and halted our progress due to the fact that linked list was not the easiest to utilize, therefore we changed our approach to tokenizing the command line, and by splitting each string up, we are then able to execute them properly.
Phase 3: For this phase, we coded in functions to represent the built in functions that needed to be implemented. We made functions that were activated by certain conditions, those conditions pertaining to the first index of the array of arguments, and whether it was either "pwd" or "cd". Then, depending on which one it was, a function was called which performed the indicated action. We tested all of our functions by simply inputting the command that was relevant and observing the output and adjusting accordingly. 
Phase 4: First, we detected a greater than sign in the command line, then we check to see if there is content after the greater than sign, and store that in a string, and we use that as the output for the redirection. After this, we open the file from the command line and then, before executing the command, we clear the greater than sign and everything afterwards, so it does not show up in the output. That text is then appended to the text file if it already exists, however if it doesn't exist, a new file is then created. 
Phase 5: We had difficulty pipelining, we first looked at the lecture slides, and then we went to the internet and looked at as many sources as possible in order to implement pipelining, however we did not implement this feature in time, not due to our conceptual knowledge of the topic, rather the difficulty of implementing it. 
Phase 6: The output appending feature, we added an extra function that iterated through the command line looking for the first instance of ">", then after that it looked to see if the character right after that is also a ">", and if it was, then we would return an int value that reflected that. However, we could not get this part of our project to operate properly, which led to this feature not being implemented fully. The sls command was similar to the built in commands, we looked at the source provided to us by in the form of the GNU-Libc document. We took the bulk of the example given to us in the source and repurposed it in order to implement the sls command. 
